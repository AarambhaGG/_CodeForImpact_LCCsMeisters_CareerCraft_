[
  {
    "skill": "Python",
    "level": "LEVEL_1",
    "question_type": "MULTIPLE_CHOICE",
    "question_text": "What is the output of print(2 ** 3)?",
    "options": ["6", "8", "9", "23"],
    "correct_answer": "8",
    "explanation": "The ** operator in Python is for exponentiation. 2 ** 3 means 2 to the power of 3, which equals 8.",
    "points": 10,
    "time_limit_seconds": 60
  },
  {
    "skill": "Python",
    "level": "LEVEL_1",
    "question_type": "MULTIPLE_CHOICE",
    "question_text": "Which of the following is a valid variable name in Python?",
    "options": ["2variable", "variable-name", "variable_name", "variable name"],
    "correct_answer": "variable_name",
    "explanation": "Python variable names must start with a letter or underscore, and can contain letters, numbers, and underscores. They cannot contain spaces or hyphens.",
    "points": 10,
    "time_limit_seconds": 60
  },
  {
    "skill": "Python",
    "level": "LEVEL_1",
    "question_type": "TRUE_FALSE",
    "question_text": "Python is a case-sensitive language.",
    "options": ["True", "False"],
    "correct_answer": "true",
    "explanation": "Python is case-sensitive, meaning 'Variable' and 'variable' are treated as different identifiers.",
    "points": 10,
    "time_limit_seconds": 45
  },
  {
    "skill": "Python",
    "level": "LEVEL_1",
    "question_type": "MULTIPLE_CHOICE",
    "question_text": "What data type is the value 3.14 in Python?",
    "options": ["int", "float", "str", "decimal"],
    "correct_answer": "float",
    "explanation": "Numbers with decimal points are stored as floating-point numbers (float) in Python.",
    "points": 10,
    "time_limit_seconds": 60
  },
  {
    "skill": "Python",
    "level": "LEVEL_1",
    "question_type": "MULTIPLE_CHOICE",
    "question_text": "How do you create a comment in Python?",
    "options": ["// This is a comment", "/* This is a comment */", "# This is a comment", "<!-- This is a comment -->"],
    "correct_answer": "# This is a comment",
    "explanation": "In Python, comments start with the # symbol. Everything after # on that line is ignored by the interpreter.",
    "points": 10,
    "time_limit_seconds": 60
  },
  {
    "skill": "Python",
    "level": "LEVEL_2",
    "question_type": "MULTIPLE_CHOICE",
    "question_text": "What will be the output of: len([1, 2, 3, 4, 5])?",
    "options": ["4", "5", "6", "Error"],
    "correct_answer": "5",
    "explanation": "The len() function returns the number of items in a list. This list contains 5 elements, so len() returns 5.",
    "points": 10,
    "time_limit_seconds": 90
  },
  {
    "skill": "Python",
    "level": "LEVEL_2",
    "question_type": "CODE_SNIPPET",
    "question_text": "What is the output of the following code?",
    "code_snippet": "def greet(name=\"World\"):\n    return f\"Hello, {name}!\"\nprint(greet())",
    "options": ["Hello, !", "Hello, World!", "Hello, name!", "Error"],
    "correct_answer": "Hello, World!",
    "explanation": "The function has a default parameter value of 'World'. When called without arguments, it uses the default value.",
    "points": 10,
    "time_limit_seconds": 120
  },
  {
    "skill": "Python",
    "level": "LEVEL_2",
    "question_type": "MULTIPLE_CHOICE",
    "question_text": "Which method is used to add an element to the end of a list?",
    "options": ["add()", "append()", "insert()", "push()"],
    "correct_answer": "append()",
    "explanation": "The append() method adds a single element to the end of a list. add() and push() don't exist, insert() requires an index.",
    "points": 10,
    "time_limit_seconds": 90
  },
  {
    "skill": "Python",
    "level": "LEVEL_2",
    "question_type": "MULTIPLE_CHOICE",
    "question_text": "What is a dictionary in Python?",
    "options": ["An ordered collection of items", "A key-value pair collection", "A collection of unique items", "A sequential list"],
    "correct_answer": "A key-value pair collection",
    "explanation": "A dictionary is an unordered collection of key-value pairs, where each key must be unique and immutable.",
    "points": 10,
    "time_limit_seconds": 90
  },
  {
    "skill": "Python",
    "level": "LEVEL_2",
    "question_type": "TRUE_FALSE",
    "question_text": "List comprehensions are faster than traditional for loops in Python.",
    "options": ["True", "False"],
    "correct_answer": "true",
    "explanation": "List comprehensions are generally faster than equivalent for loops because they are optimized at the C level in CPython.",
    "points": 10,
    "time_limit_seconds": 75
  },
  {
    "skill": "Python",
    "level": "LEVEL_3",
    "question_type": "CODE_SNIPPET",
    "question_text": "What is the output of the following code?",
    "code_snippet": "nums = [1, 2, 3, 4, 5]\nresult = [x**2 for x in nums if x % 2 == 0]\nprint(result)",
    "options": ["[1, 4, 9, 16, 25]", "[4, 16]", "[2, 4]", "[1, 9, 25]"],
    "correct_answer": "[4, 16]",
    "explanation": "This list comprehension squares only the even numbers (2 and 4). 2²=4 and 4²=16.",
    "points": 10,
    "time_limit_seconds": 150
  },
  {
    "skill": "Python",
    "level": "LEVEL_3",
    "question_type": "MULTIPLE_CHOICE",
    "question_text": "What is the purpose of the __init__ method in a Python class?",
    "options": ["To delete an object", "To initialize object attributes", "To define class methods", "To create a class variable"],
    "correct_answer": "To initialize object attributes",
    "explanation": "__init__ is the constructor method that initializes the object's attributes when an instance is created.",
    "points": 10,
    "time_limit_seconds": 120
  },
  {
    "skill": "Python",
    "level": "LEVEL_3",
    "question_type": "MULTIPLE_CHOICE",
    "question_text": "Which of the following is used to handle exceptions in Python?",
    "options": ["try-catch", "try-except", "catch-throw", "error-handle"],
    "correct_answer": "try-except",
    "explanation": "Python uses try-except blocks for exception handling, unlike some languages that use try-catch.",
    "points": 10,
    "time_limit_seconds": 120
  },
  {
    "skill": "Python",
    "level": "LEVEL_3",
    "question_type": "MULTIPLE_CHOICE",
    "question_text": "What is a decorator in Python?",
    "options": ["A function that modifies another function", "A way to decorate strings", "A type of loop", "A class method"],
    "correct_answer": "A function that modifies another function",
    "explanation": "Decorators are functions that take another function as argument and extend its behavior without modifying it.",
    "points": 10,
    "time_limit_seconds": 150
  },
  {
    "skill": "Python",
    "level": "LEVEL_3",
    "question_type": "CODE_SNIPPET",
    "question_text": "What is the output?",
    "code_snippet": "def outer():\n    x = 10\n    def inner():\n        nonlocal x\n        x += 5\n        return x\n    return inner()\nprint(outer())",
    "options": ["10", "15", "5", "Error"],
    "correct_answer": "15",
    "explanation": "The 'nonlocal' keyword allows inner() to modify the variable x from outer's scope. So x becomes 10+5=15.",
    "points": 10,
    "time_limit_seconds": 180
  },
  {
    "skill": "Python",
    "level": "LEVEL_4",
    "question_type": "CODE_SNIPPET",
    "question_text": "What design pattern is demonstrated in this code?",
    "code_snippet": "class Singleton:\n    _instance = None\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance",
    "options": ["Factory Pattern", "Singleton Pattern", "Observer Pattern", "Decorator Pattern"],
    "correct_answer": "Singleton Pattern",
    "explanation": "This implements the Singleton pattern, ensuring only one instance of the class can exist by overriding __new__.",
    "points": 10,
    "time_limit_seconds": 180
  },
  {
    "skill": "Python",
    "level": "LEVEL_4",
    "question_type": "MULTIPLE_CHOICE",
    "question_text": "What is the purpose of the @property decorator?",
    "options": ["To create static methods", "To create getter methods for attributes", "To create class methods", "To define constants"],
    "correct_answer": "To create getter methods for attributes",
    "explanation": "@property allows you to define methods that can be accessed like attributes, providing controlled access to class data.",
    "points": 10,
    "time_limit_seconds": 150
  },
  {
    "skill": "Python",
    "level": "LEVEL_4",
    "question_type": "MULTIPLE_CHOICE",
    "question_text": "What is the Global Interpreter Lock (GIL) in Python?",
    "options": ["A lock for global variables", "A mechanism that allows only one thread to execute Python bytecode at a time", "A security feature", "A performance optimization"],
    "correct_answer": "A mechanism that allows only one thread to execute Python bytecode at a time",
    "explanation": "The GIL is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes simultaneously.",
    "points": 10,
    "time_limit_seconds": 150
  },
  {
    "skill": "Python",
    "level": "LEVEL_4",
    "question_type": "CODE_SNIPPET",
    "question_text": "What will this metaclass do?",
    "code_snippet": "class Meta(type):\n    def __new__(cls, name, bases, dct):\n        dct['greeting'] = 'Hello'\n        return super().__new__(cls, name, bases, dct)",
    "options": ["Add a 'greeting' attribute to all instances", "Add a 'greeting' class attribute to classes using this metaclass", "Create a greeting method", "Raise an error"],
    "correct_answer": "Add a 'greeting' class attribute to classes using this metaclass",
    "explanation": "Metaclasses customize class creation. This one adds a 'greeting' class attribute to any class that uses it as a metaclass.",
    "points": 10,
    "time_limit_seconds": 200
  },
  {
    "skill": "Python",
    "level": "LEVEL_4",
    "question_type": "MULTIPLE_CHOICE",
    "question_text": "What is the difference between @staticmethod and @classmethod?",
    "options": ["staticmethod takes cls as first parameter, classmethod doesn't", "classmethod takes cls as first parameter, staticmethod takes no implicit parameter", "They are the same", "staticmethod is faster"],
    "correct_answer": "classmethod takes cls as first parameter, staticmethod takes no implicit parameter",
    "explanation": "@classmethod receives the class as the first argument (cls), while @staticmethod receives no implicit first argument.",
    "points": 10,
    "time_limit_seconds": 150
  },
  {
    "skill": "Python",
    "level": "LEVEL_5",
    "question_type": "CODE_SNIPPET",
    "question_text": "What is the time complexity of this function?",
    "code_snippet": "def fibonacci(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fibonacci(n-1, memo) + fibonacci(n-2, memo)\n    return memo[n]",
    "options": ["O(2^n)", "O(n)", "O(n²)", "O(log n)"],
    "correct_answer": "O(n)",
    "explanation": "This uses memoization to cache results, reducing the time complexity from O(2^n) to O(n).",
    "points": 10,
    "time_limit_seconds": 240
  },
  {
    "skill": "Python",
    "level": "LEVEL_5",
    "question_type": "MULTIPLE_CHOICE",
    "question_text": "What is the purpose of the __slots__ attribute in a Python class?",
    "options": ["To define method slots", "To restrict the attributes and save memory", "To create private variables", "To enable multiple inheritance"],
    "correct_answer": "To restrict the attributes and save memory",
    "explanation": "__slots__ restricts the attributes a class can have and uses a more memory-efficient storage mechanism instead of __dict__.",
    "points": 10,
    "time_limit_seconds": 180
  },
  {
    "skill": "Python",
    "level": "LEVEL_5",
    "question_type": "SCENARIO",
    "question_text": "You need to implement a thread-safe singleton in Python. Which approach would you use?",
    "options": ["Use threading.Lock() in __new__", "Use @synchronized decorator", "Use global variable", "Singletons can't be thread-safe"],
    "correct_answer": "Use threading.Lock() in __new__",
    "explanation": "To make a singleton thread-safe, you need to use a lock to ensure only one thread can create the instance at a time, typically using threading.Lock().",
    "points": 10,
    "time_limit_seconds": 240
  },
  {
    "skill": "Python",
    "level": "LEVEL_5",
    "question_type": "CODE_SNIPPET",
    "question_text": "What pattern is this implementing?",
    "code_snippet": "from functools import wraps\ndef cache(func):\n    memo = {}\n    @wraps(func)\n    def wrapper(*args):\n        if args not in memo:\n            memo[args] = func(*args)\n        return memo[args]\n    return wrapper",
    "options": ["Observer Pattern", "Memoization/Caching Pattern", "Factory Pattern", "Strategy Pattern"],
    "correct_answer": "Memoization/Caching Pattern",
    "explanation": "This is a memoization decorator that caches function results based on arguments to avoid recomputation.",
    "points": 10,
    "time_limit_seconds": 240
  },
  {
    "skill": "Python",
    "level": "LEVEL_5",
    "question_type": "MULTIPLE_CHOICE",
    "question_text": "What is the difference between deepcopy and shallow copy in Python?",
    "options": ["deepcopy is faster", "deepcopy recursively copies nested objects, shallow copy doesn't", "They are the same", "shallow copy is more memory efficient"],
    "correct_answer": "deepcopy recursively copies nested objects, shallow copy doesn't",
    "explanation": "A shallow copy creates a new object but references the same nested objects. A deep copy recursively creates new copies of all nested objects.",
    "points": 10,
    "time_limit_seconds": 180
  }
]
